SA1$Z
data(mosquito)
gdf <- geomorph.data.frame(wingshape = mosquito$wingshape,
ind = mosquito$ind,
side = mosquito$side,
replicate = mosquito$replicate)
WS <- gpagen(gdf$wingshape)
M2 <- two.d.array(WS$coords)
mosquito.sym <- bilat.symmetry(A = WS,
ind = ind,
side = side,
replicate = replicate,
object.sym = FALSE,
RRPP = TRUE,
iter = 999,
data = gdf,
seed = 123,
SS.type = "I")
procA2 <- procD.lm(M2 ~ gdf$ind + gdf$side + gdf$ind/gdf$side,
iter = 999,
seed = 123,
RRPP = T,
SS.type = "I")
SA1 <- SA2 <- anova(procA2)$table
procA2 <- procD.lm(M2 ~ gdf$ind + gdf$side + gdf$ind/gdf$side,
iter = 999,
seed = 123,
RRPP = T,
SS.type = "I",
effect.type = "F")
SA1 <- SA2 <- anova(procA2)$table
SA1$Z[is.nan(SA1$Z)] <- SA2$Z[is.nan(SA2$Z)] <- NA
SA3 <- mosquito.sym$shape.anova
MS <- procA2$ANOVA$MS
RSS <- procA2$ANOVA$RSS
procA2$ANOVA$Fs
random.shape.F <- MS/MSE
MS <- random.shape.F <- procA2$ANOVA$MS
MS/MSE
random.shape.F
mosquito.sym <- bilat.symmetry(A = WS,
ind = ind,
side = side,
replicate = replicate,
object.sym = FALSE,
RRPP = TRUE,
iter = 999,
data = gdf,
seed = 123,
SS.type = "I")
procA2 <- procD.lm(M2 ~ gdf$ind + gdf$side + gdf$ind/gdf$side,
iter = 999,
seed = 123,
RRPP = T,
SS.type = "I",
effect.type = "F")
SA1 <- SA2 <- anova(procA2)$table
SA1$Z[is.nan(SA1$Z)] <- SA2$Z[is.nan(SA2$Z)] <- NA
SA3 <- mosquito.sym$shape.anova
MS <- procA2$ANOVA$MS
RSS <- procA2$ANOVA$RSS
MSE <- RSS/matrix(procA2$ANOVA$df[nrow(RSS) + 1], nrow(RSS),
ncol(RSS))
random.shape.F <- MS/MSE
MS <- random.shape.F <- procA2$ANOVA$MS
MS.mod <- procA2$ANOVA$RSS.model[3, ]/procA2$ANOVA$df[4]
random.shape.F[1, ] <- MS[1, ]/MS[3, ]
random.shape.F[2, ] <- MS[2, ]/MS[3, ]
random.shape.F[3, ] <- procA2$ANOVA$Fs[3, ]
newZ <- apply(random.shape.F, 1, geomorph:::effect.size)
newP <- apply(random.shape.F, 1, geomorph:::pval)
SA1$F[1:3] <- random.shape.F[1:3, 1]
SA1$Z[1:3] <- newZ
SA1[[ncol(SA1)]][1:3] <- newP
SA1
SA3
SA2
mosquito.sym <- bilat.symmetry(A = WS,
ind = ind,
side = side,
replicate = replicate,
object.sym = FALSE,
RRPP = F,
iter = 999,
data = gdf,
seed = 123,
SS.type = "I")
procA2 <- procD.lm(M2 ~ gdf$ind + gdf$side + gdf$ind/gdf$side,
iter = 999,
seed = 123,
RRPP = F,
SS.type = "I",
effect.type = "F")
SA1 <- SA2 <- anova(procA2)$table
SA1$Z[is.nan(SA1$Z)] <- SA2$Z[is.nan(SA2$Z)] <- NA
SA3 <- mosquito.sym$shape.anova
MS <- procA2$ANOVA$MS
RSS <- procA2$ANOVA$RSS
MSE <- RSS/matrix(procA2$ANOVA$df[nrow(RSS) + 1], nrow(RSS),
ncol(RSS))
random.shape.F <- MS/MSE
MS <- random.shape.F <- procA2$ANOVA$MS
MS.mod <- procA2$ANOVA$RSS.model[3, ]/procA2$ANOVA$df[4]
random.shape.F[1, ] <- MS[1, ]/MS[3, ]
random.shape.F[2, ] <- MS[2, ]/MS[3, ]
random.shape.F[3, ] <- procA2$ANOVA$Fs[3, ]
newZ <- apply(random.shape.F, 1, geomorph:::effect.size)
newP <- apply(random.shape.F, 1, geomorph:::pval)
SA1$F[1:3] <- random.shape.F[1:3, 1]
SA1$Z[1:3] <- newZ
SA1[[ncol(SA1)]][1:3] <- newP
SA1
SA3
SA2
procD.lm()
procD.lm
----------------------------------------------------------------
source(file = "Rfunctions1.txt") # Functions from Claude 2008
library(scales)
library(car)
library(rgl)
library(geomorph)
library(EMMLi)
library(paleomorph)
#--------------------
source(file = "Rfunctions1.txt") # Functions from Claude 2008
library(scales)
library(car)
library(rgl)
library(geomorph)
library(EMMLi)
library(paleomorph)
# Define color scale
color <- hcl.colors(30,
palette = "viridis",
alpha = NULL,
rev = FALSE,
fixup = TRUE)
# Covariance matrix, with individual coordinates as variables
pdf(file = paste(output_folder,
"covariance_heatmap.pdf",
sep = "/"),
height = 8,
width = 8)
image(x = 1:dim(cov_overall)[1],
y = 1:dim(cov_overall)[1],
z = cov_overall,
col = color,
main = "Landmarks covariance matrix",
xlab = "",
ylab = "",
xaxt = "n",
yaxt = "n")
abline(h = c(51.5, 78.5),
v = c(51.5, 78.5),
col = "grey",
lwd = 3)
dev.off()
# Correlation matrix, with individual coordinates as variables
pdf(file = paste(output_folder,
"correlation_heatmap.pdf",
sep = "/"),
height = 8,
width = 8)
image(x = 1:dim(cor_overall)[1],
y = 1:dim(cor_overall)[1],
z = cor_overall,
col = color,
main = "Landmarks correlation matrix",
xlab = "",
ylab = "",
xaxt = "n",
yaxt = "n")
abline(h = c(51.5, 78.5),
v = c(51.5, 78.5),
col = "grey",
lwd = 3)
dev.off()
# Congruence matrix, with landmarks congruence coefficients as variables
pdf(file = paste(output_folder,
"congruence_heatmap.pdf",
sep = "/"),
height = 8,
width = 8)
image(x = 1:dim(congru_overall)[1],
y = 1:dim(congru_overall)[1],
z = congru_overall,
col = color,
main = "Landmarks congruence matrix",
xlab = "",
ylab = "",
xaxt = "n",
yaxt = "n")
abline(v = c(17.5, 26.5),
h = c(17.5, 26.5),
lwd = 3,
col = "grey")
label_head <- DF[-c(LM_LM, LM_RM), 10]
label_LM <- DF[LM_LM, 10]
label_RM <- DF[LM_RM, 10]
lab_congru <- c(label_head, label_LM, label_RM)
axis(side = 1,
at = 1:dim(congru_overall)[2],
labels = lab_congru,
las = 2)
axis(side = 2,
at = 1:dim(congru_overall)[2],
labels = lab_congru,
las = 2)
dev.off()
# Congruence matrix plot with reordered LMs, and integration test results
lab_congro <- lab_congru
lab_congro[1:17] <- lab_congru[order(modu_head[,1])] # Order head LMs names by
# the module they belong to
rpls_val <- paste("r-PLS =",
round(integ_test_4mod$r.pls.mat, 3))
p_val <- paste("P =", integ_test_4mod$pairwise.P.values)
parts <- levels(part_overall2)
pdf(file = paste(output_folder,
"LM_correlation_module_congruence.pdf",
sep = "/"),
height = 8,
width = 11)
par(mar = c(4, 8, 6, 4))
image(x = 1:dim(m)[1],
y = 1:dim(m)[1],
z = m,
col = color,
xlab = "",
ylab = "",
xaxt = "n",
yaxt = "n")
title(main = "Landmarks congruence matrix",
line = 5)
abline(v = c(8.5, 17.5, 26.5),
h = c(8.5, 17.5, 26.5),
lwd = 3,
col = "grey")
axis(side = 1,
at =  c(4.5, 13, 22, 31),
labels = parts,
font = 2,
las = 1)
axis(side = 2,
at =  c(4.5, 13, 22, 31),
labels = parts,
font = 2, las = 3)
axis(side = 4,
at = 1:dim(congro_overall)[2],
labels = lab_congro,
las = 2)
axis(side = 3,
at = 1:dim(congro_overall)[2],
labels = lab_congro,
las = 2)
legend(x = -5,
y = 35.5,
xpd = T,
legend = round(seq(min(na.omit(c(m))),
max(na.omit(c(m))),
length = length(color)), 2),
col = color,
pch = 15)
text(x = c(rep(4.5, 3), rep(13, 2), 22),
y = c(13, 22, 31, 22, 31, 31),
labels = rpls_val,
pos = 3)
text(x = c(rep(4.5, 3), rep(13, 2), 22),
y = c(13, 22, 31, 22, 31, 31),
labels = p_val,
pos = 1)
dev.off()
# Possible artifact from alignment of left and right mandibles. May artificially
# increase correlation between homologous landmarks
shp_mand
?modularity.test
part_overall
dim(A_overall)
dim(A_overall[18:35,,])
plot(A_overall[18:35,1,], A_overall[18:35,2,])
plot(A_overall[18:26,1,], A_overall[18:26,2,])
points(A_overall[27:35,1,], A_overall[27:35,2,], col =2)
integration.test(A = mat_overall,
partition.gp = part_overall,
iter = 999)
?integration.test
part_overall
part_overall[18:35]
mod_test_mand <- modularity.test(A = A_overall[18:35,,],
partition.gp = droplevels(part_overall[18:35]),
iter = 999,
CI = T)
mod_test_mand
?modularity.test
droplevels(part_overall[18:35])
modul_test_2
modul_test_7
mod_test_mand
modul_test_4
modul_test_4$CR
modul_test_4$CR.mat
liz.sym
0.23678/0.032119
liz.sym.noRRPP
l
l <- rnorm(n = 50, mean = 1, sd = 0.2)
l
r
rr <- l + rnorm(n = 50, mean = 0.3, sd = 0.2)
r <- l + rnorm(n = 50, mean = 0.3, sd = 0.2)
r
l
plot(l,r)
boxplot(plot(l,r))
boxplot(l,r)
# Simulate replicated measurements
lr <- l + rnorm(n = 50, mean = 0.05, sd = 0.05)
rr <- r + rnorm(n = 50, mean = 0.05, sd = 0.05)
cbind(l, r, lr, rr)
c(cbind(l, r, lr, rr))
c(rbind(l, r, lr, rr))
# Vector of value. 4 consectuvie values correspond to one individual
v <- c(rbind(l, r, lr, rr))
# Vector of left "length"
l <- rnorm(n = 50, mean = 1, sd = 0.2)
# Vector of right "length", right is longer than left
r <- l + rnorm(n = 50, mean = 0.3, sd = 0.2)
# Simulate replicated measurements
lr <- l + rnorm(n = 50, mean = 0.05, sd = 0.05)
rr <- r + rnorm(n = 50, mean = 0.05, sd = 0.05)
# Vector of value. 4 consectuvie values correspond to one individual
v <- c(rbind(l, r, lr, rr))
# Paste into array
A <- array(data = v,
dim = c(1, 1, length(v)))
A
ind <- rep(1:length(l), each = 4)
ind
rep(c("L", "R"), each = 2)
side <- rep(rep(c("L", "R"), each = 2), length(l))
side
side <- as.factor(rep(rep(c("L", "R"),
each = 2),
length(l)))
ind <- as.factor(rep(1:length(l),
each = 4))
boxplot(v ~ side)
boxplot(v ~ ind)
# Vector of left "length"
l <- rnorm(n = 50, mean = 1, sd = 0.2)
# Vector of right "length", right is longer than left
r <- l + rnorm(n = 50, mean = 0.3, sd = 0.1)
# Simulate replicated measurements
lr <- l + rnorm(n = 50, mean = 0.05, sd = 0.05)
rr <- r + rnorm(n = 50, mean = 0.05, sd = 0.05)
# Vector of value. 4 consectuvie values correspond to one individual
v <- c(rbind(l, r, lr, rr))
# Paste into array
A <- array(data = v,
dim = c(1, 1, length(v)))
ind <- as.factor(rep(1:length(l),
each = 4))
side <- as.factor(rep(rep(c("L", "R"),
each = 2),
length(l)))
boxplot(v ~ ind)
boxplot(v ~ side)
side <- as.factor(rep(rep(c("L", "R"),
length(l) * 2)))
side
boxplot(v ~ side)
side <- as.factor(rep(c("L", "R"),
length(l) * 2))
side
replicate <- as.factor(rep(rep(c(0, 1),
each = 2)),
length(l))
rep(c(0, 1),
each = 2)
replicate <- as.factor(rep(rep(c(0, 1),
each = 2),
length(l)))
replicate
replicate <- as.factor(rep(rep(c(1, 2),
each = 2),
length(l)))
replicate
bilat.symmetry(A = A, ind = ind, side = side, replicate = replicate, object.sym = F)
lm.rrpp(v ~ ind + side + ind/side)
lms <- lm.rrpp(v ~ ind + side + ind/side)
summary(lms)
anova(lms)
lms <- lm.rrpp(v ~ ind + side + ind/side, RRPP = F)
lms <- lm.rrpp(v ~ ind + side + ind/side)
lms.norrpp <- lm.rrpp(v ~ ind + side + ind/side, RRPP = F)
anova(lms)
anova(lms.norrpp)
# Vector of left "length"
l <- rnorm(n = 50, mean = 1, sd = 0.2)
# Vector of right "length", right is longer than left
r <- l + rnorm(n = 50, mean = 1, sd = 0.1)
# Simulate replicated measurements
lr <- l + rnorm(n = 50, mean = 0.05, sd = 0.05)
rr <- r + rnorm(n = 50, mean = 0.05, sd = 0.05)
# Vector of value. 4 consectuvie values correspond to one individual
v <- c(rbind(l, r, lr, rr))
# Paste into array
A <- array(data = v,
dim = c(1, 1, length(v)))
ind <- as.factor(rep(1:length(l),
each = 4))
side <- as.factor(rep(c("L", "R"),
length(l) * 2))
replicate <- as.factor(rep(rep(c(1, 2),
each = 2),
length(l)))
lms <- lm.rrpp(v ~ ind + side + ind/side)
lms.norrpp <- lm.rrpp(v ~ ind + side + ind/side, RRPP = F)
anova(lms)
anova(lms.norrpp)
# Vector of left "length"
l <- rnorm(n = 50, mean = 1, sd = 0.5)
# Vector of right "length", right is longer than left
r <- l + rnorm(n = 50, mean = 1, sd = 0.1)
# Simulate replicated measurements
lr <- l + rnorm(n = 50, mean = 0.05, sd = 0.05)
rr <- r + rnorm(n = 50, mean = 0.05, sd = 0.05)
# Vector of value. 4 consectuvie values correspond to one individual
v <- c(rbind(l, r, lr, rr))
# Paste into array
A <- array(data = v,
dim = c(1, 1, length(v)))
ind <- as.factor(rep(1:length(l),
each = 4))
side <- as.factor(rep(c("L", "R"),
length(l) * 2))
replicate <- as.factor(rep(rep(c(1, 2),
each = 2),
length(l)))
lms <- lm.rrpp(v ~ ind + side + ind/side)
lms.norrpp <- lm.rrpp(v ~ ind + side + ind/side, RRPP = F)
anova(lms)
anova(lms.norrpp)
# Vector of left "length"
l <- rnorm(n = 50, mean = 1, sd = 0.1)
# Vector of right "length", right is longer than left
r <- l + rnorm(n = 50, mean = 1, sd = 0.5)
# Simulate replicated measurements
lr <- l + rnorm(n = 50, mean = 0.05, sd = 0.05)
rr <- r + rnorm(n = 50, mean = 0.05, sd = 0.05)
# Vector of value. 4 consectuvie values correspond to one individual
v <- c(rbind(l, r, lr, rr))
# Paste into array
A <- array(data = v,
dim = c(1, 1, length(v)))
ind <- as.factor(rep(1:length(l),
each = 4))
side <- as.factor(rep(c("L", "R"),
length(l) * 2))
replicate <- as.factor(rep(rep(c(1, 2),
each = 2),
length(l)))
lms <- lm.rrpp(v ~ ind + side + ind/side)
lms.norrpp <- lm.rrpp(v ~ ind + side + ind/side, RRPP = F)
anova(lms)
anova(lms.norrpp)
# Vector of left "length"
l <- rnorm(n = 50, mean = 1, sd = 0.1)
# Vector of right "length", right is longer than left
r <- l + rnorm(n = 50, mean = 2, sd = 0.5)
# Simulate replicated measurements
lr <- l + rnorm(n = 50, mean = 0.05, sd = 0.05)
rr <- r + rnorm(n = 50, mean = 0.05, sd = 0.05)
# Vector of value. 4 consectuvie values correspond to one individual
v <- c(rbind(l, r, lr, rr))
# Paste into array
A <- array(data = v,
dim = c(1, 1, length(v)))
ind <- as.factor(rep(1:length(l),
each = 4))
side <- as.factor(rep(c("L", "R"),
length(l) * 2))
replicate <- as.factor(rep(rep(c(1, 2),
each = 2),
length(l)))
lms <- lm.rrpp(v ~ ind + side + ind/side)
lms.norrpp <- lm.rrpp(v ~ ind + side + ind/side, RRPP = F)
anova(lms)
anova(lms.norrpp)
# Vector of left "length"
l <- rnorm(n = 50, mean = 0.5, sd = 0.1)
# Vector of right "length", right is longer than left
r <- l + rnorm(n = 50, mean = 2, sd = 0.5)
# Simulate replicated measurements
lr <- l + rnorm(n = 50, mean = 0.05, sd = 0.05)
rr <- r + rnorm(n = 50, mean = 0.05, sd = 0.05)
# Vector of value. 4 consectuvie values correspond to one individual
v <- c(rbind(l, r, lr, rr))
# Paste into array
A <- array(data = v,
dim = c(1, 1, length(v)))
ind <- as.factor(rep(1:length(l),
each = 4))
side <- as.factor(rep(c("L", "R"),
length(l) * 2))
replicate <- as.factor(rep(rep(c(1, 2),
each = 2),
length(l)))
lms <- lm.rrpp(v ~ ind + side + ind/side)
lms.norrpp <- lm.rrpp(v ~ ind + side + ind/side, RRPP = F)
anova(lms)
anova(lms.norrpp)
