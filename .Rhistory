N_sample = nrow(M),
mod = DF,
abs = F)
EMMLi(corr = as.data.frame(cor_M),
N_sample = nrow(M),
mod = DF_3,
abs = F)
?EMMLi
cent
centroid
lower.tri(matrix(NA, ncol = 20, nrow = 20))
A[1, 1:3,]
mshape(A[1, 1:3,])
mshape(A[1,,])
A[1,,]
A[-1,,]
A[-c(1:5),,]
A[1:2,,]
A
A[1,,]
A[1,,] %*% mshp_real[1,]
mshp_real[1,]
A[1,,1] %*% mshp_real[1,]
apply(A[1,,], MARGIN = 2, FUN = "%*%", mshp_real[1,])
apply(A[1,,], MARGIN = 2, FUN = "-", mshp_real[1,])
A[1,,1] - mshp_real[1,]
A[1,,] - mshp_real[1,]
A[1,,] - mshp_real[1,] == apply(A[1,,], MARGIN = 2, FUN = "-", mshp_real[1,])
A[1,,]
A[1,,]^2
sum(A[1,,]^2)
congruence_coef <- function(A) {
N <- dim(A)[3]
P <- dim(A)[1]
K <- dim(A)[2]
mshp <- mshape(A)
mat <- matrix(NA,
ncol = P,
nrow = P)
for (i in 1:P) {
for (j in 1:P) {
li <- A[i,,]
lj <- A[j,,]
ui <- mshp[i,]
uj <- mshp[j,]
num <- sum((li - ui) %*% (lj - uj))
denom <- sqrt(sum(li^2) * sum(lj^2))
Rij <- num / denom
mat[i, j] <- Rij
}
}
print(mat)}
M <-congruence_coef(A = av_A)
congruence_coef <- function(A) {
N <- dim(A)[3]
P <- dim(A)[1]
K <- dim(A)[2]
mshp <- mshape(A)
mat <- matrix(NA,
ncol = P,
nrow = P)
for (i in 1:P) {
for (j in 1:P) {
li <- A[i,,]
lj <- A[j,,]
ui <- mshp[i,]
uj <- mshp[j,]
num <- sum(apply(X = li - ui,
MARGIN = 2,
FUN = "%*%",
lj - uj))
denom <- sqrt(sum(li^2) * sum(lj^2))
Rij <- num / denom
mat[i, j] <- Rij
}
}
print(mat)}
M <-congruence_coef(A = av_A)
M
congruence_coef <- function(A) {
N <- dim(A)[3]
P <- dim(A)[1]
K <- dim(A)[2]
mshp <- mshape(A)
mat <- matrix(NA,
ncol = P,
nrow = P)
for (i in 1:P) {
for (j in 1:P) {
li <- A[i,,]
lj <- A[j,,]
ui <- mshp[i,]
uj <- mshp[j,]
num <- sum(apply(X = li - ui,
MARGIN = 2,
FUN = "%*%",
lj - uj))
denom <- sqrt(sum(li^2) * sum(lj^2))
Rij <- num / denom
mat[i, j] <- Rij
}
}
return(mat)
}
M <-congruence_coef(A = av_A)
M
A[1,,1]
(A[1,,1] - mshp_real[1,])
(A[1,,1] - mshp_real[1,]) * (A[2,,1] - mshp_real[2,])
(A[1,,1] - mshp_real[1,]) %*% (A[2,,1] - mshp_real[2,])
(A[1,,1] - mshp_real[1,]) %*% (A[1,,1] - mshp_real[1,])
(A[1,,1] - mshp_real[1,]) %*% t(A[1,,1] - mshp_real[1,])
(A[1,,1] - mshp_real[1,]) %*% (A[1,,1] - mshp_real[1,])
sum((A[1,,1] - mshp_real[1,]) * (A[1,,1] - mshp_real[1,]))
av_A[1,,]
congruence_coef <- function(A) {
N <- dim(A)[3]
P <- dim(A)[1]
K <- dim(A)[2]
mshp <- mshape(A)
mat <- matrix(NA,
ncol = P,
nrow = P)
for (i in 1:P) {
for (j in 1:P) {
ui <- mshp[i,]
uj <- mshp[j,]
dprod <- rep(NA, N)
for (n in 1:N) {
li <- A[i,,n]
lj <- A[j,,n]
dprod[n] <- (li - ui) %*% (lj - uj)
}
num <- sum(dprod)
Li2 <- A[i,,]^2
Lj2 <- A[j,,]^2
denom <- sqrt(sum(Li2) * sum(Lj2))
Rij <- num / denom
mat[i, j] <- Rij
}
}
return(mat)
}
congruence_coef(av_A)
lower.tri(congruence_coef(av_A))
lowertriang(congruence_coef(av_A))
M <- congruence_coef(av_A)
dim(M)
M
isSymmetric(M)
A <- av_A #No need for replicates
M <- matrix(NA,
nrow = dim(A)[3],
ncol = dim(A)[2] * dim(A)[1])
for (i in 1:dim(A)[3]) {M[i,] <- c(t(A[,,i]))}
DF <- df_modul_models[-c(8:10),]
DF_3 <- data.frame(apply(X = DF,
MARGIN = 2,
FUN = rep,
each = 3))
DF_3[, 2:6] <- apply(X = DF_3[, 2:6],
MARGIN = 2,
FUN = as.numeric)
cor_M <- cor(M)
EMMLi(corr = as.data.frame(cor_M),
N_sample = nrow(M),
mod = DF_3,
abs = F)
EMMLi(corr = as.data.frame(cor_M),
N_sample = nrow(M),
mod = DF_3,
abs = T)
DF_3
EMMLi(corr = as.data.frame(cor_M),
N_sample = nrow(M),
mod = DF_3,
abs = T)
getwd()
f <- "output_EMMLi_individual_coord.csv"
EMMLi(corr = as.data.frame(cor_M),
N_sample = nrow(M),
mod = DF_3,
abs = T,
saveAs = f)
congruence_coef <- function(A) {
N <- dim(A)[3]
P <- dim(A)[1]
K <- dim(A)[2]
mshp <- mshape(A)
mat <- matrix(NA,
ncol = P,
nrow = P)
for (i in 1:P) {
for (j in 1:P) {
ui <- mshp[i,]
uj <- mshp[j,]
dprod <- rep(NA, N)
for (n in 1:N) {
li <- A[i,,n]
lj <- A[j,,n]
dprod[n] <- (li - ui) %*% (lj - uj)
}
num <- sum(dprod)
Li2 <- A[i,,]^2
Lj2 <- A[j,,]^2
denom <- sqrt(sum(Li2) * sum(Lj2))
Rij <- num / denom
mat[i, j] <- Rij
}
}
return(mat)
}
M <- congruence_coef(av_A)
M
?%*%
?"%*%"
?dot
mshp
mshp[1,]%*%t(mshp[1,])
t(mshp[1,])%*%mshp[1,]
mshp[1,]%*%mshp[1,]
library(geometry)
?dot
dot(mshp[,1], mshp[,1])
dot(mshp[1,], mshp[1,])
modul_test_1
DF
modul_test_2
modul_test_1
modul_test_3
modul_test_4
integ_test_1
integ_test_2
integ_test_3
integ_test_4
?integration.test
compare.pls(integ_test_4)
compare.pls(integ_test_1, integ_test_4)
?modularity.test
compare.pls(integ_test_1,
integ_test_2,
integ_test_3,
integ_test_4)
modul_test_1
modul_test_2
modul_test_3
modul_test_4
?compare.CR
compare.CR(modul_test_1,
modul_test_2, modul_test_3, modul_test_4)
modul_test_1
modul_test_2
modul_test_3
modul_test_4
compare.CR(modul_test_1,
modul_test_2,
modul_test_3,
modul_test_4)
modul_test_1
#Geomorph much simpler tests
modul_test_0 <- modularity.test(A = A,
partition.gp = DF[,0],
iter = 999,
CI = T)
#Geomorph much simpler tests
modul_test_0 <- modularity.test(A = A,
partition.gp = DF[,2],
iter = 999,
CI = T)
#Geomorph much simpler tests
modul_test_0 <- modularity.test(A = A,
partition.gp = DF[,2],
iter = 999,
CI = T)
modul_test_1 <- modularity.test(A = A,
partition.gp = DF[,3],
iter = 999,
CI = T)
DF
integ_test_0 <- integration.test(A = A,
partition.gp = DF[,2],
iter = 999)
integ_test_1 <- integration.test(A = A,
partition.gp = DF[,3],
iter = 999)
integ_compar <- compare.pls(integ_test_1,
integ_test_2,
integ_test_3,
integ_test_4)
modul_compar <- compare.CR(modul_test_1,
modul_test_2,
modul_test_3,
modul_test_4)
modul.tests$Marsh
summary(modul_compar)
summary(modul_compar)
integ_compar
?compare.pls
integ_test_1
integ_test_2
integ_test_4
plot(integ_test_1)
integ_test_1
integ_compar
modul_compar <- compare.CR(modul_test_1,
modul_test_2,
modul_test_3,
modul_test_4)
modul_compar
integ_test_1
?integration.test
DF[,5]
DF[,4]
DF[,6]
DF[,5]
integ_test_3
integ_test_4
decomp_asym
decomp_asym$M
summary(manova(lm(prcomp(decomp_asym$matshp)$x[,1:50] ~
decomp_asym$indiv.fac.mirror * decomp_asym$mirror.fac)))
?bilat.symmetry
ID
shapes$rotated
shapes
plot(shapes[,2,], shapes[,3,])
dim(shapes)
ID
replic
bilat_sym <- bilat.symmetry(A = shapes,
ind = ID,
replicate = replic,
object.sym = T)
?bilat.symmetry
text(shapes[,2,1], shapes[,3,1], col=2, labels = 1:35)
plot(shapes[,2,], shapes[,3,])
layout(1)
plot(shapes[,2,], shapes[,3,])
text(shapes[,2,1], shapes[,3,1], col=2, labels = 1:35)
LM_template
land_pairs <- list()
DF
land_pairs[[1]] <- c(3, 12)
land_pairs[[2]] <- c(4, 11)
plot(shapes[,2,], shapes[,3,])
text(shapes[,2,1], shapes[,3,1], col=2, labels = 1:35, cex = 3)
t(c(DF[,1]))
c(DF[,1])
land_pairs <- list()
land_pairs[[1]] <- c(3, 12)
land_pairs[[2]] <- c(4, 11)
land_pairs[[3]] <- c(5, 9)
land_pairs[[4]] <- c(6, 8)
land_pairs[[5]] <- c(7, 10)
land_pairs[[6]] <- c(3, 12)
land_pairs[[7]] <- c(14, 15)
land_pairs[[8]] <- c(16, 17)
land_pairs[[9]] <- c(18, 21)
land_pairs[[10]] <- c(19, 22)
land_pairs[[11]] <- c(20, 23)
land_pairs[[12]] <- c(24, 25)
land_pairs[[13]] <- c(26, 30)
land_pairs[[14]] <- c(27, 31)
land_pairs[[15]] <- c(28, 32)
land_pairs[[16]] <- c(29, 33)
land_pairs[[17]] <- c(34, 35)
land_pairs
bilat_sym <- bilat.symmetry(A = shapes,
ind = ID,
replicate = replic,
object.sym = T,
land.pairs = land_pairs)
unlist(land_pairs)
as.matrix(unlist(land_pairs), ncol = 2, byrow = T)
matrix(unlist(land_pairs), ncol = 2, byrow = T)
land_pairs <- matrix(unlist(land_pairs),
ncol = 2,
byrow = T)
bilat_sym <- bilat.symmetry(A = shapes,
ind = ID,
replicate = replic,
object.sym = T,
land.pairs = land_pairs)
bilat_sym
bilat_sym <- bilat.symmetry(A = shapes,
ind = ID,
replicate = replic,
object.sym = T,
land.pairs = land_pairs,SS.type = "II")
bilat_sym
summary(manova(lm(prcomp(decomp_asym$matshp)$x[,1:50] ~
decomp_asym$indiv.fac.mirror * decomp_asym$mirror.fac)))
summary(manova(lm(prcomp(decomp_asym$matshp)$x[,1] ~
decomp_asym$indiv.fac.mirror * decomp_asym$mirror.fac)))
summary(manova(lm(prcomp(decomp_asym$matshp)$x[,1:2] ~
decomp_asym$indiv.fac.mirror * decomp_asym$mirror.fac)))
?bilat.symmetry
bilat_sym <- bilat.symmetry(A = shapes,
ind = ID,
replicate = replic,
object.sym = T,
land.pairs = land_pairs)
bilat_sym$signed.AI
TQ
TA
cor.test(bilat_sym$signed.AI, TA)
bilat_sym$DA.component
plot(bilat_sym$DA.component[,,1])
plot(bilat_sym$DA.component[,2:3,1], asp=1, pch = 20)
plot(bilat_sym$DA.component[,c(1,3),1], asp=1, pch = 20)
plot(bilat_sym$DA.component[,c(1,2),1], asp=1, pch = 20)
plot(bilat_sym$DA.component[,c(2,1),1], asp=1, pch = 20)
points(bilat_sym$DA.component[,c(2,1),2], asp=1, pch = 20, col = 2)
bilat_sym$FA.component
cor.test(bilat_sym$signed.AI, bf)
cor.test(bilat_sym$signed.AI, bf2)
cor.test(bilat_sym$signed.AI, mbf2)
cor.test(bilat_sym$signed.AI, mbf)
plot(bilat_sym$signed.AI, bf)
plot(bilat_sym$signed.AI, bf2)
modul_compar
?cat
integ_test_1
?integration.test
bilat_sym
?bilat.symmetry
integ_test_4
?modularity.test
DF[,3]
DF[,5]
newpart <- DF[,5]
newpart[which(newpart == 1)] <- NA
newpart
integ_test_5 <- integration.test(A = A,
partition.gp = newpart,
iter = 999)
integ_test_5
integ_compar <- compare.pls(integ_test_1,
integ_test_2,
integ_test_3,
integ_test_4,
integ_test_5)
integ_compar
?two.b.pls
A <- av_A #No need for replicates
integ_test_5 <- integration.test(A = A,
partition.gp = newpart,
iter = 999)
integ_test_5
integ_test_5 <- integration.test(A = A,
partition.gp = newpart,
iter = 999)
integ_test_5
which(DF[,5] == 2 | DF[,5] == 3)
A1 <- A[which(DF[,5] == 2),,]
A2 <- A[which(DF[,5] == 3),,]
tbpls <- two.b.pls(A1 = A1,
A2 = A2)
tbpls
TA
DA
var(DA)
var(bf2)
bf2
var(bf2, na.rm = T)
sd(bf2, na.rm = T)/mean(bf2, na.rm = T)
sd(DA, na.rm = T)/mean(DA, na.rm = T)
modul_compar <- compare.CR(modul_test_1,
modul_test_2,
modul_test_3,
modul_test_4)
modul_compar
integ_test_1
TA
DA
cor.test(TA, DA)
sd(DA)/mean(DA)
sd(DA)/mean(abs(DA))
sd(BF)/mean(abs(BF))
bf
bf2
cor.test(DA,bf)
cor.test(DA,bf2)
sd(bf, na.rm = T)/mean(bf, na.rm = T)
csiz
sd(csiz, na.rm = T)/mean(csiz, na.rm = T)
sd(HL, na.rm = T)/mean(HL, na.rm = T)
sd(head_l, na.rm = T)/mean(head_l, na.rm = T)
sd(TA, na.rm = T)/mean(TA, na.rm = T)
CVTA <- sd(TA, na.rm = T)/mean(TA, na.rm = T)
CVDA <- sd(DA, na.rm = T)/mean(abs(DA), na.rm = T)
CVBF <- sd(bf, na.rm = T)/mean(bf, na.rm = T)
CVBF2 <- sd(bf2, na.rm = T)/mean(bf2, na.rm = T)
CVHL <- sd(head_l, na.rm = T)/mean(head_l, na.rm = T)
CVsiz <- sd(csiz, na.rm = T)/mean(csiz, na.rm = T)
CVTA
hist(TA)
hist(TA, xlim = c(0,0.2))
shapiro.test(TA)
shapiro.test(DA)
bilat_sym
0.02410/0.59138
0.05559/0.59138
0.14689/0.59138
0.36480/0.59138
mat1 <- matrix(c(0,2,3,1,0,2,2,0.5,0), ncol =3)
mat1
mat2 <- matrix(c(0,1,2,1,0,0.5,2,0.5,0), ncol =3)
mat2
mat1*mat1
mat1%*%mat1
help("%*%")
